 The BAI index format can handle individual chromosomes up to 512 Mbp (2^29 bases) in length. If your input file might contain reads mapped to positions greater than that, you will need to use a CSI index. 
 
 HMM (Hidden Markov Model)
 
 bin BAI index bin, see Section 4.2.1 uint16 t
 
 tid => Al menos son bins
 
 Ver remora?
 
 Ver mas de terminologia
 
 reversed reads y todo eso; mates, etc
 
 
 Linear alignment An alignment of a read to a single reference sequence that may include insertions,
deletions, skips and clipping, but may not include direction changes (i.e., one portion of the alignment
on forward strand and another portion of alignment on reverse strand). A linear alignment can be
represented in a single SAM record. <= Que hago con segmentos que tienenmas de un SAM record => no me va a dar con la info de uno solo...


Multiple mapping The correct placement of a read may be ambiguous, e.g., due to repeats. In this case,
there may be multiple read alignments for the same read. One of these alignments is considered
primary. All the other alignments have the secondary alignment flag set in the SAM records that
represent them. All the SAM records have the same QNAME and the same values for 0x40 and 0x80
flags. Typically the alignment designated primary is the best alignment, but the decision may be
arbitrary.


Unmapped reads


PI Predicted median insert size
KS The array of nucleotide bases that correspond to the key sequence of each read

Señal partida en chunks

soft-clipping and hard-clipping

BIN is calculated using the reg2bin()

leer specs enteros SAM

Unmapped reads at the end of the file (RNAME '*' in SAM)

Hacer script de Python y dsp pasar a C?


bam_iter => Para leer con index
bam_aux => para tags



def compute_read_index(self):
    bam_was_closed = self.bam_fh is None
    if bam_was_closed:
        self.open()
    self._bam_idx = defaultdict(list)
    pbar = tqdm(
        smoothing=0,
        unit=" Reads",
        desc="Indexing BAM by read id",
        disable=os.environ.get("LOG_SAFE", False),
    )
    self.num_records = 0
    # iterating over file handle gives incorrect pointers
    while True:
        read_ptr = self.bam_fh.tell()
        try:
            read = next(self.bam_fh)
        except StopIteration:
            break
        pbar.update()
        if self.req_tags is not None:
            tags = set(tg[0] for tg in read.tags)
            if not self.req_tags.issubset(tags):
                LOGGER.debug(
                    f"{read.query_name} missing tags "
                    f"{self.req_tags.difference(tags)}"
                )
                continue
        index_read_id = (
            read.query_name
            if self.read_id_converter is None
            else self.read_id_converter(read.query_name)
        )
        if self.skip_non_primary and (
            not read_is_primary(read) or index_read_id in self._bam_idx
        ):
            LOGGER.debug(f"{read.query_name} not primary")
            continue
        self.num_records += 1
        self._bam_idx[index_read_id].append(read_ptr)
    # close bam if it was closed at start of function call
    if bam_was_closed:
        self.close()
    pbar.close()
    # convert defaultdict to dict
    self._bam_idx = dict(self._bam_idx)
    self.num_reads = len(self._bam_idx)

def parse_move_tag(
    mv_tag, sig_len, seq_len=None, check=True, reverse_signal=False
):
    stride = mv_tag[0]
    mv_table = np.array(mv_tag[1:])
    query_to_signal = np.nonzero(mv_table)[0] * stride
    query_to_signal = np.concatenate([query_to_signal, [sig_len]])
    if reverse_signal:
        query_to_signal = sig_len - query_to_signal[::-1]
    if check and seq_len is not None and query_to_signal.size - 1 != seq_len:
        LOGGER.debug(
            f"Move table (num moves: {query_to_signal.size - 1}) discordant "
            f"with basecalls (seq len: {seq_len})"
        )
        raise RemoraError("Move table discordant with basecalls")
    if check and mv_table.size != sig_len // stride:
        LOGGER.debug(
            f"Move table (len: {mv_table.size}) discordant with "
            f"signal (sig len // stride: {sig_len // stride})"
        )
        raise RemoraError("Move table discordant with signal")
    return query_to_signal, mv_table, stride


ASK::
read_id_converter (Callable[[str], str]): Function to convert read ids
    (e.g. for concatenated duplex read ids)


(base) [rafael.castelli.ottati@lnano BAM_TEST]$ ls -alh | grep .bam
-rw-r--r-- 1 rafael.castelli.ottati ens          3.3G Sep 20  2020 calls2ref.bam
-rw-r--r-- 1 rafael.castelli.ottati ens          999K Sep 20  2020 calls2ref.bam.bai
(base) [rafael.castelli.ottati@lnano BAM_TEST]$ ls -alh | grep .pod5
-rw-r--r-- 1 rafael.castelli.ottati ens          974M Jul 27 14:45 batch15.pod5
(base) [rafael.castelli.ottati@lnano BAM_TEST]$ ls -alh | grep .fast5
-rw-r--r-- 1 rafael.castelli.ottati ens         1022M Sep 20  2020 batch15.fast5
(base) [rafael.castelli.ottati@lnano BAM_TEST]$ ls
batch15.fast5  batch15.pod5  calls2ref.bam  calls2ref.bam.bai  filename_mapping.txt
(base) [rafael.castelli.ottati@lnano BAM_TEST]$ time /data/pgnanoraw/pod5_fork/pod5/python/pod5/venv/bin/python /data/pgnanoraw/pod5_fork/src/python/pgnano/prototypes/index_bam
149707it [00:23, 6245.97it/s]

real	0m24.081s
user	0m23.298s
sys	0m0.744s
(base) [rafael.castelli.ottati@lnano BAM_TEST]$ 

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    55     56.8 MiB     56.8 MiB           1       @profile
    56                                             def compute_read_index(self):
    57     56.8 MiB      0.0 MiB           1           bam_was_closed = self.bam_fh is None
    58     56.8 MiB      0.0 MiB           1           if bam_was_closed:
    59     58.8 MiB      2.0 MiB           1               self.open()
    60     58.8 MiB      0.0 MiB           1           self._bam_idx = defaultdict(list)
    61     58.9 MiB      0.1 MiB           1           pbar = tqdm()
    62     58.9 MiB      0.0 MiB           1           self.num_records = 0
    63                                                 # iterating over file handle gives incorrect pointers
    64     92.7 MiB   -346.6 MiB      149708           while True:
    65     92.7 MiB   -358.2 MiB      149708               read_ptr = self.bam_fh.tell()
    66     92.7 MiB   -355.2 MiB      149708               try:
    67     92.7 MiB   -354.9 MiB      149708                   read = next(self.bam_fh)
    68     92.7 MiB      0.0 MiB           1               except StopIteration:
    69     92.7 MiB      0.0 MiB           1                   break
    70     92.7 MiB   -357.7 MiB      149707               pbar.update()
    71     92.7 MiB   -358.0 MiB      149707               index_read_id = (
    72     92.7 MiB   -345.1 MiB      149707                   read.query_name
    73     92.7 MiB   -358.0 MiB      149707                   if self.read_id_converter is None
    74                                                         else self.read_id_converter(read.query_name)
    75                                                     )
    76     92.7 MiB   -358.0 MiB      149707               self.num_records += 1
    77     92.7 MiB   -355.1 MiB      149707               self._bam_idx[index_read_id].append(read_ptr)
    78                                                 # close bam if it was closed at start of function call
    79     92.7 MiB      0.0 MiB           1           if bam_was_closed:
    80     92.5 MiB     -0.3 MiB           1               self.close()
    81     92.5 MiB      0.0 MiB           1           pbar.close()
    82                                                 # convert defaultdict to dict
    83     92.5 MiB      0.0 MiB           1           self._bam_idx = dict(self._bam_idx)
    84     92.5 MiB      0.0 MiB           1           self.num_reads = len(self._bam_idx)

IMP:::
El index podes cargarlo lazily


 39, 26, 25, 23, 28, 33, 23, 23, 35, 19, 20, 20, 21, 9, 9, 14, 14, 14, 19, 22, 20, 22, 27, 6, 7, 17, 8, 15, 20, 12, 13, 13, 19, 25, 24, 21, 36, 38, 35, 33, 34, 31, 29, 18, 18, 23, 34, 29, 39, 45, 39, 35, 11, 37, 38, 31, 28, 36, 27, 26, 29, 28, 36, 26, 30, 29, 32, 34, 45, 48, 30, 26, 22, 26, 20, 23, 22, 22, 23, 36, 34, 21, 27, 27, 30, 19, 21, 16, 19, 21, 6, 3, 6, 10, 3, 2, 4, 15, 18, 13, 23, 10, 17, 24, 20, 28, 34, 20, 30, 32, 35, 35, 25, 35, 24, 17, 25, 21, 21, 15, 32, 33, 26, 29, 32, 36, 36, 35, 32, 31, 39, 34, 39, 37, 31, 36, 37, 30, 30, 24, 40, 40, 21, 31, 24, 31, 29, 30, 33, 27, 35, 38, 30, 28, 35, 27, 33, 41, 33, 32, 33, 33, 30, 34, 31, 44, 42, 30, 29, 37, 30, 23, 26, 32, 23, 11, 11, 16, 12, 5, 5, 7, 4, 7, 10, 7, 12, 9, 6, 16, 3, 4, 4, 5, 16, 5, 12, 15, 17, 18, 9, 5, 18, 10, 3, 3, 6, 4, 3, 3, 5, 7])      [('NM', 25), ('ms', 490), ('AS', 490), ('nn', 0), ('tp', 'P'), ('cm', 35), ('s1', 224), ('s2', 47), ('dv', 0.038100000470876694)]

IMP:::
Ellos no usan index, usan otra alternativa que quizas sirva => ver index_bam.py


Problemas de endianness en cabezal compresor

    def seek(self, Py_ssize_t offset, int whence=SEEK_SET):
    
IMP::
Signalbuilder => Ver init@ signal_table_writer@356 y el tema de movable 
Ver memory leaks



IMP:::
GO Grouping of alignments, indicating that similar alignment records are grouped together but the
file is not necessarily sorted overall. Valid values: none (default), query (alignments are grouped
by QNAME), and reference (alignments are grouped by RNAME/POS).


IMP:::
QNAME: Query template NAME. Reads/segments having identical QNAME are regarded to come from
the same template. A QNAME ‘*’ indicates the information is unavailable. In a SAM file, a read may
occupy multiple alignment lines, when its alignment is chimeric or when multiple mappings are given

IMP:::
Sorted SAM y busqueda binaria? => eso mas lo de seek puede mejorar una bocha la eficiencia
TMB podes agregar filtrado por tid o RNAME


IMP:::IMP:::IMP:::
IMP:::IMP:::IMP:::
IMP:::IMP:::IMP:::
Si, sería buena idea hacer el build de custom SAM index a memoria de forma lazy, pero recordar 
que el BAM_HANDLER tiene fuertes requerimientos de thread safety para la lectura

IMP:::IMP:::IMP:::
IMP:::IMP:::IMP:::
IMP:::IMP:::IMP:::
Markov

IMP:::IMP:::IMP:::
IMP:::IMP:::IMP:::
IMP:::IMP:::IMP:::
IMP:::IMP:::IMP:::
IMP:::IMP:::IMP:::
IMP:::IMP:::IMP:::
# class IndexedReads    index a SAM/BAM/CRAM file by query name while keeping
#                       the original sort order intact
# class IndexedReads    index a SAM/BAM/CRAM file by query name while keeping
#                       the original sort order intact
cdef class IndexedReads:

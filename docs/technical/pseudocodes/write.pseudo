void escribir: 
    out: destino_salida, 
    read_count: int,
    run_info_count: int, 
    reads_array: Read[],
    signal_array: Signal[],
    signal_lenght: int[],
    run_info_array: RunInfo[]
    reads_belongs_run_info: map<int, int>
BEGIN
    map<OldRunInfoIdx, NewRunInfoIdx> new_run_info_idx

    init POD5
    writer = create empty output file
    
    for i in range(0, run_info_count):
        new_idx = add run_info to writer 
        add <i, new_idx> new_run_info_idx

    flattened_array[] = flatten_array(read_count, reads_array, signal_array, new_run_info_idx)
    pod5_add_reads_data(writer, flattened_array, signal_array, signal_lenght)
END

/*
* Arrow y por tanto POD5 manejan una representación columnar de los datos
* En particular una tabla que tenga los valores [(x1,y1), (x2,y2), (x3,y3)]
* Se va a representar como ([x1,x2,x3], [y1,y2,y3])
* Entonces el cliente debe pasar sus datos tabulares a este formato
* Además se deben generar un conjunto de índices los datos representados
* Como diccionarios, por ejemplo el tipo de poro
*/
ReadBatchRowInfoArray_t flatten_array:
    out: destino_salida, 
    read_count: int,
    reads_array: Read[],
    run_info_array: RunInfo[]
    reads_belongs_run_info: map<int, int>
    run_info_idx_map: map<OldRunInfoIdx, NewRunInfoIdx>
BEGIN
    pore_type_map: map<PoreType, int>
    end_reason_map: map<EndReason, int>
    for x in __campos__:
        crear array x[read_count]
    for i in range(0, read_count):
        // copias de valores directos
        for x in {
                    read_id, read_number, start_sample, median_before,
                    channel, well, calibration_offset, calibration_scale,
                    end_reason_forced, num_minknow_events,
                    tracked_scaling_scale, tracked_scaling_shift,
                    predicted_scaling_scale, predicted_scaling_shift,
                    num_reads_since_mux_change, time_since_mux_change,
                 }
            x[i] = reads_array[i].x
        // copias de índices y asociaciones
        //pore_type
        if reads_array[i].pore_type in pore_type_map:
            pore_type[i] = pore_type_map(reads_array[i].pore_type)
        else
            new_idx = pod5_add_pore(reads_array[i].pore_type, writer)
            pore_type_map.add(reads_array[i].pore_type, new_idx)

        //end_reason
        if reads_array[i].end_reason in end_reason_map:
            end_reason[i] = end_reason_map(reads_array[i].end_reason)
        else
            new_end_reason_idx = pod5_get_end_reason(reads_array[i].end_reason)
            end_reason_map.add(reads_array[i].end_reason, new_end_reason_idx)
        
        //run_info_id
        run_info_id[i] = run_info_idx_map(reads_array[i].run_info_id)
END

Protocolo: <Stateless en POD5, Stateful en cliente>
    => Cliente agrega los run_info al archivo
    <= POD5 retorna los IDs de estos run_info
    parallel_section
    {
        {
            => Cliente agrega los tipos de poro al archivo
            <= POD5 retorna los IDs de estos tipos de poro
        };
        {
            => Cliente agrega los end_reason al archivo
            <= POD5 retorna los ID de estos end_reason en el archivo
        }
    };
    El cliente asocia a cada read, el ID de run info que le corresponde
    El cliente sustituye el tipo de poro de cada read por el ID que le dio POD5
    El cliente sustituye el end_reason de cada read por el ID que le dio POD5
    => Cliente envía los reads con los cambios anteriors + señal de cada read (con su largo)
Termina protocolo de escritura

